
4. Configuração do Jogador e Câmera (Lógica Matemática)
Objetivo: Definir a posição e o campo de visão iniciais do jogador.

Esta etapa é puramente matemática e não usa funções da minilibx.

Use a posição inicial (x, y) e o caractere de direção (N, S, E, W) que você extraiu do mapa.

Defina o vetor de direção do jogador (por exemplo, dirX = 0, dirY = -1 para 'N').

Defina o plano da câmera, que é perpendicular ao vetor de direção e controla a largura do campo de visão (FOV). Por exemplo, para 'N', o plano da câmera poderia ser planeX = 0.66, planeY = 0.

        Estrutura de Dados: O ideal é adicionar novas variáveis à sua struct s_map (ou criar uma nova struct s_player) para guardar a posição, a direção e o plano da câmera. Essas variáveis devem ser do tipo double ou float para permitir movimentos suaves e cálculos precisos.

        posX, posY: A posição do jogador no mapa (você já tem isso, mas agora em ponto flutuante).

        dirX, dirY: O vetor de direção, que representa para onde o jogador está olhando. É um vetor unitário (comprimento 1).

        planeX, planeY: O vetor do plano da câmera. Ele é perpendicular ao vetor de direção e define a largura do seu campo de visão (FOV). Um valor comum para a magnitude do plano da câmera é 0.66, que cria um FOV de 66 graus, um valor confortável.

        Inicialização: Com base na letra de início (N, S, E, W) que você leu do mapa:

        Se for 'N' (Norte):

        dirX = 0.0, dirY = -1.0 (apontando para o "topo" do mapa).

        planeX = 0.66, planeY = 0.0 (o plano da câmera se estende horizontalmente).

        Se for 'S' (Sul):

        dirX = 0.0, dirY = 1.0.

        planeX = -0.66, planeY = 0.0.

        Se for 'E' (Leste):

        dirX = 1.0, dirY = 0.0.

        planeX = 0.0, planeY = 0.66.

        Se for 'W' (Oeste):

        dirX = -1.0, dirY = 0.0.

        planeX = 0.0, planeY = -0.66.

---------------------------------------------------------------

5. Implementação do Raycasting e Renderização
Objetivo: Desenhar o mundo 3D na sua imagem de buffer.

Detalhes:

Loop Principal: A função que contém a lógica de renderização será registrada usando mlx_loop_hook.

Função de Renderização: Dentro desta função:

Itere por cada coluna de pixels da tela (de x = 0 até a largura da janela).

Calcule a direção do raio para a coluna x atual.

Algoritmo DDA: Percorra a grade do mapa passo a passo, seguindo o raio, até atingir uma parede.

Calcule a Distância: Determine a distância perpendicular do jogador até a parede para evitar o efeito "olho de peixe".

Calcule a Altura da Parede: Com base na distância, calcule a altura da fatia vertical da parede a ser desenhada na tela.

Desenhe o Cenário:

Desenhe uma linha vertical para o teto com a cor que você preparou.

Desenhe a fatia da parede, aplicando a textura correta (veja o próximo passo).

Desenhe uma linha vertical para o chão com a cor apropriada.

Exibição na Tela: Após desenhar o frame inteiro na sua imagem de buffer, chame mlx_put_image_to_window para copiar o buffer para a janela de uma só vez.

---------------------------------------------------------------


6. Mapeamento de Texturas (Lógica Matemática)
Objetivo: Aplicar a textura correta na fatia de parede desenhada.

Detalhes:

Quando o raio atinge uma parede, determine qual textura usar (Norte, Sul, Leste ou Oeste).

Calcule o ponto exato (wallX) onde o raio atingiu a parede (um valor entre 0.0 e 1.0).

Use wallX para encontrar a coluna da textura (texX) a ser usada.

Ao desenhar a fatia vertical da parede na tela, para cada pixel, calcule a coordenada Y correspondente na textura (texY) e copie a cor da textura para a sua imagem de buffer.

---------------------------------------------------------------

7. Controles do Jogador (minilibx)
Objetivo: Permitir que o jogador se mova pelo cenário.

Detalhes:

mlx_hook (ou a mais simples mlx_key_hook): Registre uma função para ser chamada sempre que uma tecla for pressionada.

Dentro da função de hook, verifique o keycode da tecla pressionada:

Movimento (W, S, A, D): Altere as coordenadas posX e posY do jogador, sempre verificando se a nova posição não está dentro de uma parede (detecção de colisão).

Rotação (Setas ←, →): Gire o vetor de direção e o plano da câmera do jogador usando uma matriz de rotação.

---------------------------------------------------------------

8. Gerenciamento de Memória e Encerramento (minilibx)
Objetivo: Sair do programa de forma limpa, liberando todos os recursos.

Detalhes:

mlx_hook: Registre uma função para o evento de fechar a janela (o "X" vermelho). O nome do evento é DestroyNotify (código 17).

Função de Saída: Nesta função, você deve:

Liberar todas as suas alocações manuais (free).

mlx_destroy_image: Chame esta função para cada imagem que você criou (o buffer principal e as quatro texturas).

mlx_destroy_window: Destrua a janela.

mlx_destroy_display: Libere a conexão com o sistema gráfico.

Chame exit(0).